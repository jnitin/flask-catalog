venv
====
( ) Create a NEW venv from scratch. Do NOT copy from other location:
     ( )Temporarily remove venv activation in .bashrc
     ( )Install python3-pip, python3-venv
     ( )Follow instructions inside pip_all.sh
     ( )Restore venv activation in .bashrc


models
======
(-) user blueprint
     ( ) remove application specific columns
     ( ) remove application specific methods
     ( ) define application specific columns
     ( ) define application specific methods
     ( ) update tests_user_model.py

     (-) Delete owned entries of a user when Deleting a user

(-) catalog blueprint
     ( ) Register the blueprint
     (-) models.py
          ( ) Define ORM classes
          ( ) Define method: insert_default_items
          ( ) Call this method from catalog.py, if app.db not there.
          ( ) Remove app.db, then startup web server, and verify that app.db contains correct tables & default entries
     ( ) create tests/tests_catalog_model.py

permissions
===========
(-) Only admin can create categoriies
     (-) via web-page
     (-) via API

(-) Only logged in users can create items
     (-) via web-page
     (-) via API

branding
========
( ) Rename startup python file: catalog.py
( ) Replace icons in static (favicon.ico & img/logo* )
( ) In base.html
     ( ) meta name --> for SEO
( ) In index.html
     ( ) set page_title = '.......' --> for web-browser tab on home page
     ( ) update jumbotron content

credits
=======
( ) In index.html
     ( ) update credits

configuration
=============
(-) Update SECRET_KEY (instance/config.py)

views & html
============
(-) Add capability to add new items
(-) Add capability to edit items
(-) Add capability to delete items

auth
====

3rd party integration
=================
(-) Add google OAUTH2
     ( ) Get auth keys at google for this application
          (-) https://console.developers.google.com/apis
               (See nd004 3.11-5 instructions on Google Drive)

     ( ) Add keys to instance/config.py
     (-) LOGIN & REGISTER
          ( ) Add button & javascript to login.html, via login_oauth.html base template
          ( ) In login_oauth.html, set correct redirect upon succesful login
          ( ) gconnect method in views.py
               ( ) Create CSRF token (state) in auth.views.login and pass to template
                    (-) Test this on multiple login sessions going on at once...
               ( ) If user does not yet exist, create it.
               ( ) Register user with flask_login
               ( ) In verify password, check if password was set.
          (-) Write a unit test for Google signin
          (-) Write a e2e test for Google signin

(-) Add beerDB interface

profile pictures
============
(-) Avoid clutter in uploads folder
     (-) In tests, remove any uploaded pictures during teardown
     (-) When deleting user, make sure his uploads are deleted as well
     (-) When changing profile picture, make sure to delete previous one


api
===
(-) Delete user must also delete the Categories and Items.
(-) Create application specific package, like api/catalog, with:
     (-) model_schemas.py
     (-) views.py
     (-) __init__.py


(-) In user/models.py, update to_json() methods
     (-) In tests_items_modelpy, update to_json tests

(-) All responses must return JSON API 1.0 specification

e2e testing
===========
(-) Update e2e_tests.ipynb
(-) Test register_from_invitation route
(-) Test display of profile pic when it comes from Google

configuration
=============
(-) Put production configurations into environments, enabling heroku deployment
(-) Create multiple configs, as in Flask Web Development book

cleanup
=======
( ) Remove meal blueprint
( ) Remove api/meal package
( ) Get rid of RelationShips. Don't need them... (I think)
(-) Explanation why "type": "user"  in the POST request to register a user

code review
===========
(-) Do all POST requests return a redirect instead of render_template?
     --> This is important to avoid resubmission of forms
          (see: https://en.wikipedia.org/wiki/Post/Redirect/Get )
(-) Do all entries in HTML for forms have error printing (See login as example)
(-) Fix all Pylint Errors
(-) Fix all Pylint Warnings
(-) Fix all Pylint Info messages


deployment
==========
(-) Checklist before deployment
     (-) Did I add all required credits to index.html?
     (-) Is DEBUG mode turned off?
     (-) Is SECRET_KEY updated?

(-) Prep for deployment to heroku (Follow mega tutorial instructions...)
     ( ) Put all secret configurations into environment variables
     ( ) Upgrade to Python 3.6.2 (https://docs.google.com/document/d/1hMlS6pfl_bG0vz6ns2bG4NMRgsVdIzpyPQxIkmsOubs/edit)
     ( ) Update requirements.txt
     ( ) Implement database migration
          ( ) Follow section 4.2 of Mega Tutorial
               (-) Add extension Flask-Migrate
                    (o) This adds sub-command: flask db
               (-) Initialize migration repository:
                    (venv) $ flask db init
                    --> creates a folder ./migrations which must be put under source control
               (-) Do a database migration, with comment
                    $ flask db migrate -m "initial"    (Creates migration script)
                    $ flask db upgrade                 (Creates/Upgrades db)

                    NOTE:
                    (o) When working with database servers such as MySQL and
                        PostgreSQL, you have to create the database in the
                        database server before running upgrade.
                    (o) If you ever need to downgrade the database, use this:
                         $ flask db downgrade
                         $ rm <last migration script>
                    (o) Question: does Flask-Migrate get rid of content???
     ( ) Refactor database initialization into a cli command: flask initdb
          Test it by runnning the initdb command:
          $ flask initdb
          $ sqlitebrowser app.db   (VERIFY CONTENT)

          NOTE: initdb is NOT related to Flask-Migrate. It uses the
                standard capability of Flask, which comes with cli out of
                the box (http://flask.pocoo.org/docs/0.12/cli/)
     ( ) Prep to work with Heroku Postgres database:
          ( ) Update config.py to use DATABASE_URL environment variable, like this:
               SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
                    'sqlite:///' + os.path.join(basedir, 'app.db')
     (-) Option to log to stdout:
          --> Follow method of mega tutorial, using LOG_TO_STDOUT


(-) Deploy to heroku (Follow mega tutorial instructions...)
     ( ) install heroku CLI (https://devcenter.heroku.com/articles/heroku-cli#download-and-install)
          $ sudo snap install heroku --classic
          $ heroku --version
          heroku-cli/6.16.4 (linux-x64) node-v9.9.0
     ( ) login to heroku CLI
          $ heroku login
          NOTE: The heroku CLI saves your email address and an API token to ~/.netrc
                for future use. For more information, see Heroku CLI Authentication:
                https://devcenter.heroku.com/articles/authentication
     ( ) Create a Heroku application
          (venv) $ heroku apps:create flask-catalog
          Creating ⬢ flask-catalog... done
          https://flask-catalog.herokuapp.com/ | https://git.heroku.com/flask-catalog.git

          NOTE: The local git repository will be configured with an extra
                remote, called heroku. Verify that it exists with the git remote
                command:

          (venv) $ git remote -v

     ( ) Create a free postgressql database:

          There is a command line to do this, but it is not clear which one to use:
          $ heroku addons:add heroku-postgresql:hobby-dev        (Mega Tutorial)
          or
          $ heroku addons:create heroku-postgresql:hobby-dev     (https://elements.heroku.com/addons/heroku-postgresql)

          To avoid mistakes, I provisioned the database via the heroku website:
          --> https://elements.heroku.com/addons/heroku-postgresql
          Just login, and install it to the flask-catalog app. Then redirected to this:
          https://dashboard.heroku.com/apps/flask-catalog/resources?justInstalledAddonServiceId=6c67493d-8fc2-4cd4-9161-4f1ec11cbe69


          NOTE: The environment variable DATABASE_URL is automatically set
                     on Heroku when using a Postgres database (see below), so
                     nothing else needs to be done to prep for deployment.
                Read: https://elements.heroku.com/addons/heroku-postgresql
                      --> hobby-dev is free
                      https://www.heroku.com/postgres
                      https://www.postgresql.org/

     ( ) Add psycopg2 as a new dependency to requirements.txt

          $ pip install psycopg2
          $ pip freeze > requirements.txt

          NOTE: The application will be connecting to a Postgres database, and
                for that to work SQLAlchemy requires the psycopg2 package to be
                installed.

     ( ) Logging to stdout
          Set the LOG_TO_STDOUT environment variable

          $ heroku config:set LOG_TO_STDOUT=1
          Setting LOG_TO_STDOUT and restarting ⬢ flask-catalog... done, v4
          LOG_TO_STDOUT: 1

          (o) to view all logs of application:
          $ heroku logs

          NOTE: Heroku expects applications to log directly to stdout. Anything
                the application prints to the standard output is saved and
                returned when you use the '$ heroku logs' command.

     ( ) Add gunicorn webserver as a new dependencies to requirements.txt

          $ pip install gunicorn
          $ pip freeze > requirements.txt

          NOTE: Heroku does not provide a web server of its own. Instead, it
                expects the application to start its own web server on the port
                number given in the environment variable $PORT . Since the Flask
                development web server is not robust enough to use for production,
                I’m going to use gunicorn, the server recommended by Heroku for
                Python applications.
               (http://gunicorn.org/)


     ( ) Define all environment variables from .env on heroku as config vars

          Option 1: use the command line:
               $ heroku config:set ++++++=........     (Set a config variable)
               $ heroku config:unset ++++++            (Unset a config variable)
               $ heroku config                         (Lists all config variables)
               $ heroku config:get ++++++              (Lists a specific config variable)

          Option 2: Edit config vars on the app's settings tab on Dashboard:
               https://dashboard.heroku.com/apps/flask-catalog/settings

          Note: https://devcenter.heroku.com/articles/config-vars
                Heroku manifests config vars as environment variables to the
                application. These environment variables are persistent – they
                will remain in place across deploys and app restarts – so unless
                you need to change values, you only need to set them once.

                Whenever you set or remove a config var, your app will be restarted

     ( ) Create a Procfile and put it under source control

          Procfile:
          ---------
          web: flask db upgrade; gunicorn catalog:app

          Because the first sub-command is based on the flask command, I need to
          add the FLASK_APP environment variable:

          $ heroku config:set FLASK_APP=catalog.py

          Also, don't forget to add Procfile under source control

          NOTE: Heroku needs to know how to execute the application, and for
                that it uses a file named Procfile in the root directory of the
                application. The format of this file is simple, each line
                includes a process name, a colon, and then the command that
                starts the process.

                The most common type of application that runs on Heroku is a web
                application, and for this type of application the process name
                should be 'web'.

                Here I defined the command to start the web application as two
                commands in sequence. First I run a database migration upgrade,
                then I start the server.

     ( ) Deploy

		  ( ) First clean out the migrations in local repository and do first migration
		      (This needs to be done differently once going for a real application)
		       $ ./reset_db_migrations.sh

          ( ) Commit everything
               $ git add .
               $ git commit -m "Ready for heroku deployment"

          ( ) Push local repository to heroku, and it will be automatically deployed
               $ git push heroku master

               --> Verify that web app is running at: https://flask-catalog.herokuapp.com/
               --> Database is empty

     ( ) Reset or Initialize the database using a one-off dyno: (https://devcenter.heroku.com/articles/one-off-dynos)
          (venv) $ heroku run bash
          ~$ flask initdb

          --> Verify that database now has content

          In a new terminal window, stop the one-off dyno:
          (venv) $ heroku ps       (Shows the running dyno)

          (venv) $ heroku ps:stop run.1      (If the name is run.1)


     ( ) Testing and fixes to some issues:

          ( ) NOTE: Each time you push a change, you need to restart the one-of
                    dyno!!!

          ( ) run the unittests in one-off dyno:
          (venv) $ heroku run bash
          ~$ cd tests
          ~/tests $ python tests_user_model.py

          ( ) viewing logs with: (https://devcenter.heroku.com/articles/logging)
          $ heroku logs -n 200   (Retrieves last 200 lines)
          $ heroku logs --tail   (tailing logs)

          ( ) heroku logs showed an error. The with open(GOOGLE_OAUTH2_FILE_PATH, 'w')
              command did not work. This is because the instance folder does not
              exist. Fixed it by changing config variable to point to main folder.

          ( ) When trying out signin via Google, it gave this error:
               The JavaScript origin in the request, https://flask-catalog.herokuapp.com,
               does not match the ones authorized for the OAuth client.
               Visit https://console.developers.google.com/apis/credentials/oauthclient/524473164280-d6r6vijbej0fvj6g3m3vb6hsp3nb7n4q.apps.googleusercontent.com?project=524473164280
               to update the authorized JavaScript origins.

              Solution is to add 'https://flask-catalog.herokuapp.com' as an authorized JavaScript origin.

     (-) Remaining issues to fix:
	  (-) remove Flask-Bcrypt from project, including readme, pip_install.sh
          (-) bcrypt does not play nice with PostgreSQL...
              Fixed by not using bcrypt


promotion
=========
(-) Push project to personal git and use as project example in Toptal profile
     (-) Update README to end customer perspective.
(-) Export Jupyter notebook to HTML and use as awesome example in Toptal profile


###############################
## TO DO FOR NEXT deployment ##
###############################

(-) Refactor with Templates moved into each blueprint folder
(-) Update password
(-) Reset password
(-) Activate link in /unconfirmed : Need another confirmation email?
(-) Refactor @email.route('/confirm/<token>') to @auth.route
(-) Implement email_change request



tests of API must test all routes:
==================================


###########
## ADMIN ##
###########

Resource manager | end point name | urls                                | methods	         | Permission
-----------------|----------------|-------------------------------------|--------------------|-----------
None             | None           | /api/v1/help                        | GET                | ADMIN
None             | None           | /api/v1/invite/<string:user_email>  | POST               | ADMIN
None             | None           | /api/v1/users/<int:user_id>/unblock | POST               | ADMIN


###########
## Users ##
###########

Resource manager         | end point name  | urls                                             | methods	           | Permission
-------------------------|-----------------|--------------------------------------------------|--------------------|-----------
None                     | None            | /api/v1/token                                    | +POST              | USER
None                     | None            | /api/v1/profile_pic                              | GET, POST          | USER
UserList                 | user_list       | /api/v1/users/						              | +GET, POST          | USER
UserDetail               | user_detail     | /api/v1/users/<int:id>                           | +GET, PATCH, DELETE | USER
UserDetail               | user_detail     | /api/v1//categories/<int:category_id>/user       | +GET, PATCH, DELETE | USER
UserDetail               | user_detail     | /api/v1//items/<int:item_id>/user                | +GET, PATCH, DELETE | USER
UserCategoryRelationship | user_categories | /api/v1/users/<int:id>/relationships/categories/ | GET                | USER
UserItemRelationship     | user_items      | /api/v1/users/<int:id>/relationships/items/      | GET                | USER

################
## Categories ##
################

Resource manager | end point name | urls                                 | methods	           | Permission
-----------------|----------------|--------------------------------------|---------------------|-----------
CategoryList     | category_list   | /api/v1/categories/                 | +GET, POST           | USER
CategoryList     | category_list   | /api/v1//users/<int:id>/categories/ | +GET, POST           | USER
CategoryDetail   | category_detail | /api/v1/categories/<int:id>         | +GET, PATCH, DELETE  | USER


###########
## Items ##
###########

Resource manager | end point name  | urls                                           | methods	          | Permission
-----------------|-----------------|------------------------------------------------|---------------------|-----------
ItemList         | item_list       | /api/v1/items/	                                | +GET, POST           | USER
ItemList         | item_list       | /api/v1/users/<int:id>/items/	                | +GET, POST           | USER
ItemList         | item_list       | /api/v1/categories/<int:category_id>/items/	| +GET, POST           | USER
ItemDetail       | item_detail     | /api/v1/items/<int:id>				            | +GET, PATCH, DELETE  | USER


Get all items of a user via relationships. Do NOT create a special route...

